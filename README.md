<h1>📕1주차 STEP 2. 동시성 제어 방식 분석 보고서</h1>
<h3>1. 동시성 제어란?</h3>
<p>
  동시성 제어는 여러 프로세스나 스레드가 동시에 데이터에 접근하거나 작업을 수행할 때 발생할 수 있는 <strong>데이터 불일치</strong> 또는 <strong>경쟁 상태</strong>를 방지하고 
  <br/>
  <strong>일관성을 유지</strong>하기 위한 기법.
  <br/>
  주로 <strong>데이터베이스</strong>나 <strong>멀티 스레드 및 분산 환경</strong>에서 사용.
</p>

<h3>2. 동시성 제어가 필요한 경우</h3>  
  <ul>
    <li>
      은행 거래 : 동시에 2개 이상의 트랜잭션이 동일한 계좌에 접근하여 잔액을 수정하면, 잔액이 올바르게 갱신되지 않을 수 있음.
    </li>
    <li>
      온라인 상품 구매 : 한 제품을 여러 사용자가 동시에 구매할 때, 재고 수량을 업데이트하는 과정에서 문제가 발생할 수 있음.
    </li>
    <li>
      항공권 등 예약 시스템 : 여러 사용자가 동시에 동일한 항공편의 좌석을 예약하려고 할 때, 문제가 발생할 수 있음.
    </li>
  </ul>
<p>위의 상황들 외에도 동시성 제어가 필요한 더 많은 상황들이 존재합니다.</p>

<h3>3. 동시성 제어 기법</h3>

<h4>3.1. 락(Lock) 기반 동시성 제어</h4>
<p>
  락을 사용하여 리소스나 데이터에 대해 한 스레드나 트랜잭션이 데이터를 수정하는 동안 다른 스레드는 <strong>대기</strong>하도록 <strong>상호 배제 (Mutual Exclusive)</strong> 기능을 제공하는 방식
</p>

<ul>
  <h4>3.1.1. 락(Lock) 기반 동시성 제어 종류</h4>
  <li>
    배타적 락 (Exclusive Lock): 쓰기 작업을 하는 동안 다른 모든 접근을 막는 락
  </li>
  <li>
    공유 락 (Shared Lock): 쓰기 작업 중에도 다른 트랜잭션이 읽기 작업만을 할 수 있도록 허용하는 락
  </li>
  <h4>3.1.2 단점</h4>
  <li>
    교착 상태 (Deadlock): 여러 트랜잭션이 서로 락을 기다리다가 무한 대기 상태에 빠질 수 있다.
  </li>
  <li>
    기아 상태 (Starvation): 특정 트랜잭션이나 스레드가 영원히 리소스를 얻지 못하는 상태.
  </li>
</ul>

<h4>3.2 낙관적 동시성 제어 (Optimistic Concurrency Control)</h4>
<p>
  리소스에 락을 걸어서 선점하지 말고, <strong>동시성 문제가 발생하면 그때 가서 처리</strong>하자는 방식.
  <br/>
  데이터에 접근할 때 <strong>락을 사용하지 않고, 트랜잭션 종료 시점에 충돌을 확인</strong>한다.
</p>

<ul>
  <h4>3.2.1 특징</h4>
  <li>
    주로 읽기 작업이 많고, 쓰기 작업이 적은 환경에서 유리하다.
  </li>
  <li>
    충돌이 발생할 확률이 낮다면, 락을 사용하는 방식보다 성능이 좋다.
  </li>
  <h4>3.2.2 장점</h4>
  <li>락을 사용하지 않으므로 교착 상태 (Deadlock)이 발생하지 않는다.</li>
  <h4>3.2.3 댠점</h4>
  <li>충돌이 자주 발생하면 롤백이 많아져 성능이 떨어질 수 있다.</li>
</ul>

<h4>3.3 비관적 동시성 제어 (Pessimistic Concurrency Control)</h4>
<p>데이터에 접근하는 순간 <strong>락을 걸어 다른 트랜잭션이 접근하지 못하게</strong> 막는 방식. 충돌이 발생할 가능성이 있다고 가정하고 동작.</p>
<ul>
  <h4>3.3.1 특징</h4>
  <li>충돌이 자주 발생할 것으로 예상되는 상황에서 사용</li>
  <li>데이터 충돌을 사전에 방지하므로, 충돌 시 롤백이 필요하지 않다.</li>
  <h4>3.3.2 장점</h4>
  <li>데이터 무결성을 보장하는 수준이 매우 높다.</li>
  <h4>3.3.3 단점</h4>
  <li>데이터 자체에 락을 걸어버리므로 동시성이 떨어져 성능 손해를 보게 된다.</li>
  <li>서로 자원이 필요한 경우에 데드락이 발생할 가능성이 있다.</li>
</ul>

<h4>3.4 타임스탬프 기반 동시성 제어</h4>
<p>
  각 트랜잭션에 <strong>타임스탬프를 부여</strong>하고, 트랜잭션의 타임스탬프 순서대로 작업을 처리하는 방식으로, 충돌이 발생하면 <strong>타임스탬프가 뒤에있는 트랜잭션이 롤백</strong>
</p>
<ul>
  <h4>3.4.1 장점</h4>
  <li>락을 사용하지 않으므로 교착 상태를 피할 수 있다.</li>
  <h4>3.4.2 단점</h4>
  <li>롤백 발생 확률이 높아 성능이 떨어질 수 있다.</li>
</ul>

<h4>3.5 다중 버전 동시성 제어 (MVCC, Multi-Version Concurrency Control)</h4>
<p>
  동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나.
  <br/>
  데이터의 여러 버전을 저장하여 동시 읽기 및 쓰기 작업을 허용한다. 각 트랜잭션이 데이터의 특정 시점의 스냅샷을 읽고, 다른 트랜잭션이 데이터를 수정하더라도 읽기 작업에 영향을 주지 않음.
  <br/> 
  오늘날의 RDBMS 는 대부분 MVCC 기반으로 동작.
</p>

<ul>
  <h4>3.5.1 장점</h4>
  <li>트랜잭션 대기 시간이 없다.</li>
  <li>다른 트랜잭션이 해당 데이터를 수정해도 영향을 받지 않음.</li>
  <h4>3.5.2 단점</h4>
  <li>사용하지 않는 데이터를 정리하는 시스템이 필요</li>
  <li>데이터 버전의 충돌이 일어날 수 있음.</li>
</ul>

<h4>3.6 분산 락 (Distributed Locking)</h4>
<p>
  분산 환경에서 동시성 제어를 위해 분산 락 (Distributed Locking) 을 사용하는 경우가 많다. <br/>
  여러 노드가 동시에 동일한 리소스에 접근하는 것을 방지하기 위해, 락을 걸어 하나의 노드만 해당 리소스를 사용할 수 있게 한다.
</p>

<ul>
  <h4>3.6.1 주요 구현 방식</h4>
  <li>
    <h5>ZooKeeper</h5>
    <ul>
      <li>분산 시스템을 위한 동기화 서비스로, 분산 락과 리더 선출을 지원한다.</li>
      <li>여러 노드가 동일한 리소스에 접근하려고 할 때, ZooKeeper 를 사용해 락을 관리하고, 하나의 노드만 리소스에 접근할 수 있도록 보장.</li>
    </ul>
  </li>
  <li>    
    <h5>Redis 와 RedLock</h5>
    <ul>
      <li>Redis는 SETNX (Set if Not Exists) (키가 존재하지 않을 때에만 Set 해라) 명령을 사용하여 락을 구현할 수 있다.</li>
      <li>RedLock 알고리즘은 여러 Redis 인스턴스를 사용하여 분산 락을 안정적으로 관리하는 방법을 제안</li>
    </ul>
  </li>
</ul>

<h1>📝4. 회고록</h3>
<p>
  이번 과제에서 TDD 방식으로 개발하며 동시성을 고려하여 로직을 작성해보았습니다.<br/>
  물론 내가 작성한 로직이 현업에서는 사용하지 않는 방식이지만, 동시성을 고려하여 기능을 구현하는 과정 그 자체만으로도 평소에는 생각해보지 않았던 부분들을 다시 한번 더 바라볼 수 있게 되어 값진 경험이었습니다. <br/>
  동시성 제어에 관한 모든 테스트케이스를 통과한다고 하여도 동시성 이슈는 사라지게 되는 것이 아니라는 것을 깨달았습니다. <br/>
  왜냐면 테스트 환경 자체가 많이 제한되어 있는 상태이기도 하고, 실제 배포 환경에서는 고려해야할 여러가지 이슈들이 더 다양하기 때문에 이에따른 한계가 명확하다고 생각합니다. <br/>
  따라서 남은 주차들 동안 이런 문제들에 대해서 어떻게 다루고, 해결해야하는지 확실하게 배워가고 싶은 기대에 설렘 반, 또 얼마나 어려울까 하는 마음에 걱정 반 하는 마음입니다.
</p>
